" NOTE: SETTINGS IN THIS FILE ARE HEAVILY RIPPED OFF FROM THE DP
" lots used from https://github.com/rdlugosz/dotfiles/blob/master/vimrc

" Plugins
call plug#begin('~/.vim/plugged')

" Vim Airline improves the look & functionality of the statusline.
Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes'
" Was on fs01sb config but commented out because it caused tmux/vim to hang,
" would like to debug at some point
"Plug 'edkolev/tmuxline.vim'

" Surround.vim lets you add/change/remove surrounding chars and tags
" https://github.com/tpope/vim-surround
Plug 'tpope/vim-surround'

" Provides additional text objects
Plug 'wellle/targets.vim'

" Allow vim-surround to be repeated by .
Plug 'tpope/vim-repeat'

" Commentary.vim provides commenting for many languages Use gcc to comment out
" a line (takes a count), gc to comment out the target of a motion (for
" example, gcap to comment out a paragraph), gc in visual mode to comment out
" the selection, and gc in operator pending mode to target a comment.
" https://github.com/tpope/vim-commentary
" Plug 'tpope/vim-commentary'

" tcomment provides easy to use, file-type sensible comments for Vim. It can
" handle embedded syntax.  https://github.com/tomtom/tcomment_vim
Plug 'tomtom/tcomment_vim'

" Pairs of handy bracket mappings
Plug 'tpope/vim-unimpaired'

" Autoclose brackets
" https://github.com/LunarWatcher/auto-pairs (maintained fork of jiangmiao/auto-pairs)
Plug 'LunarWatcher/auto-pairs'

" FZF (replaces Ctrl-P, FuzzyFinder and Command-T)
Plug '~/.fzf'
Plug 'junegunn/fzf.vim'

" Tabular.vim is a plugin that aligns text by some pattern, e.g.:
" :Tab /,
" will align lines by their commas. We have some mappings set up later, like
" <leader>t: to align on symbals and <leader>t= to align on assignment.
" https://github.com/godlygeek/tabular
Plug 'godlygeek/tabular', { 'on': ['Tabularize'] }

" Indent Guides is a plugin for visually displaying indent levels in Vim.
" Toggle with <leader>ig
" https://github.com/nathanaelkane/vim-indent-guides
Plug 'nathanaelkane/vim-indent-guides'

" Creates a new text object 'i' for indentation. E.g.,
"   vii will select block of text at current indent level
"   vai will select block of text at current indent level, plus line above
"   vaI selects block of text at current indent level, plus line above & below
" http://www.vim.org/scripts/script.php?script_id=3037
Plug 'michaeljsmith/vim-indent-object'

if version >= 800
  " Asynchronous Lint Engine
  " https://github.com/dense-analysis/ale
  " ALE (Asynchronous Lint Engine) is a plugin for providing linting in NeoVim
  " and Vim 8 while you edit your text files.
  Plug 'dense-analysis/ale'
  Plug 'skaji/syntax-check-perl'
else
  " Syntax checker for many languages
  " https://github.com/scrooloose/syntastic
  Plug 'vim-syntastic/syntastic'
  " https://github.com/pmsorhaindo/syntastic-local-eslint.vim
  Plug 'pmsorhaindo/syntastic-local-eslint.vim'
endif

" Project level configurations for tabs and new lines
" Plug 'editorconfig/editorconfig-vim', { 'for': ['javascript', 'javascript.jsx'] }
Plug 'editorconfig/editorconfig-vim'

" Searches Dash.app for the word under the cursor with <leader>d
" https://github.com/rizzatti/dash.vim
Plug 'rizzatti/dash.vim'

" Adds the :G family of commands for grepping. Automatically decides between
" Ag, Ack and Grep depending on what's available.
" https://github.com/rizzatti/greper.vim
" Plug 'rizzatti/greper.vim'

if (has('python') || has('python3')) && version >= 704
  " UltiSnips - The ultimate snippet solution for Vim.
  " https://github.com/SirVer/ultisnips
  Plug 'SirVer/ultisnips'
else
  " SnipMate aims to provide support for textual snippets, similar to TextMate
  " or other Vim plugins. Activate by typing some text and hitting <tab>.
  " Snipmate depends on tlib and mw-utils.
  " https://github.com/garbas/vim-snipmate
  Plug 'tomtom/tlib_vim'
  Plug 'MarcWeber/vim-addon-mw-utils'
  Plug 'garbas/vim-snipmate'
endif
" Actual snippets
Plug 'honza/vim-snippets'
" Snippets for react
" https://github.com/justinj/vim-react-snippets
Plug 'justinj/vim-react-snippets'

if version > 703
  " Shows git diff in the gutter
  " https://github.com/airblade/vim-gitgutter
  Plug 'airblade/vim-gitgutter'
endif

" Adds git commands
Plug 'tpope/vim-fugitive' | Plug 'tpope/vim-rhubarb'

" show multipanes when editing a COMMIT_EDITMSG
Plug 'rhysd/committia.vim'

" Better visual star searching
Plug 'bronson/vim-visual-star-search'

" A set of mappings for HTML, XML, PHP, ASP, eRuby, JSP, and more (formerly allml)
Plug 'tpope/vim-ragtag'

" Reopen files where you left off last time
" https://github.com/dietsche/vim-lastplace
Plug 'dietsche/vim-lastplace'

" Add file manip commands like Remove, Move, Rename, SudoWrite
Plug 'tpope/vim-eunuch'

" Easier agrument wrapping
Plug 'FooSoft/vim-argwrap'

" add gS to smart split lines like comma lists and html tags
" gS to split a one-liner into multiple lines
" gJ (with the cursor on the first line of a block) to join a block into a single-line statement
Plug 'AndrewRadev/splitjoin.vim'

" Save sessions
Plug 'xolox/vim-misc' | Plug 'xolox/vim-session'

" Ask what file you wanted to open when its not a real file
Plug 'EinfachToll/DidYouMean'

" Language syntax support
Plug 'tpope/vim-markdown', { 'for': 'markdown' }
Plug 'tpope/vim-git'

" Python support
" This small script modifies Vimâ€™s indentation behavior to comply with PEP8 and my aesthetic preferences.
Plug 'Vimjas/vim-python-pep8-indent'
" Pythonsense is a Vim plugin that provides text objects and motions for Python classes, methods, functions, and doc strings.
Plug 'jeetsukumaran/vim-pythonsense'

" Tools and environment to make Vim superb for developing with Node.jS
" https://github.com/moll/vim-node
Plug 'moll/vim-node', { 'for': ['javascript', 'javascript.jsx'] }

" Javascript Syntax Support
Plug 'elzr/vim-json'

" Typescript support
Plug 'Quramy/tsuquyomi'
Plug 'leafgarland/typescript-vim'
Plug 'peitalin/vim-jsx-typescript'

" Javascript / JSX syntax
" pangloss/vim-javascript is actively maintained with built-in JSX support
" https://github.com/pangloss/vim-javascript
Plug 'pangloss/vim-javascript'
" https://github.com/MaxMellon/vim-jsx-pretty
Plug 'MaxMellon/vim-jsx-pretty'
let g:javascript_plugin_jsdoc = 1

" JSDoc auto-snippets
" <leader>pd on function to insert jsdoc above
Plug 'heavenshell/vim-jsdoc'

" PHP Syntax Supoort
" https://github.com/StanAngeloff/php.vim
Plug 'StanAngeloff/php.vim'

" A collection of language packs for Vim - Probably includes most of the ones
" from above
" https://github.com/sheerun/vim-polyglot
"Plug 'sheerun/vim-polyglot'

" PHP Refactor tool
" https://github.com/adoy/vim-php-refactoring-toolbox
" Plug 'adoy/vim-php-refactoring-toolbox'

" Emoji! ðŸ˜„
Plug 'junegunn/vim-emoji'

" Color schemes
Plug 'altercation/vim-colors-solarized'
"Plug 'sickill/vim-monokai'
Plug 'lbrieden21/vim-monokai'
" Plug 'jpo/vim-railscasts-theme'
Plug 'mhartington/oceanic-next'
Plug 'morhetz/gruvbox'
Plug 'sjl/badwolf'
Plug 'sheerun/vim-wombat-scheme'
" Plug 'flazz/vim-colorschemes' " literal crapload of colorschemes

" VDebug debugger
" Plug 'joonty/vdebug'

" Provides database access to many dbms (Oracle, Sybase, Microsoft, MySQL, DBI,..)
" https://github.com/vim-scripts/dbext.vim
" Plug 'vim-scripts/dbext.vim'

" Other tpope fun
" ga - Print the unicode value of the character under the cursor in decimal,
" hexadecimal and octal, along with the unicode name, HTML entity, Emoji code,
" and any available |digraphs|.
" https://github.com/tpope/vim-characterize
Plug 'tpope/vim-characterize'
" enhance CTRL-A/CTRL-X to increment dates, times, and more
" https://github.com/tpope/vim-speeddating
Plug 'tpope/vim-speeddating'
" jdaddy.vim: JSON manipulation and pretty printing
" * aj provides a text object for the outermost JSON object, array, string, number, or keyword.
" * gqaj "pretty prints" (wraps/indents/sorts keys/otherwise cleans up) the JSON construct under the cursor.
" * gwaj takes the JSON object on the clipboard and extends it into the JSON object under the cursor.
" * There are also ij variants that target innermost rather than outermost JSON construct.
" https://github.com/tpope/vim-jdaddy
Plug 'tpope/vim-jdaddy'
" obsession.vim: continuously updated session files
" https://github.com/tpope/vim-obsession
" Plug 'tpope/vim-obsession'
" tbone.vim: Basic tmux support for Vim.
" :Tmux lets you call any old tmux command (with really good tab complete).
" :Tyank and :Tput give you direct access to tmux buffers.
" :Twrite sends a chunk of text to another pane. Give an argument like windowtitle.2, top-right, or last, or let it default to the previously given argument.
" :Tattach lets you use a specific tmux session from outside of it.
" https://github.com/tpope/vim-tbone
" Plug 'tpope/vim-tbone'
" Create Git release commits and tags with changelogs
" https://github.com/tpope/git-bump
" Plug 'tpope/git-bump'

" VIM Table Mode for instant table creation
" https://github.com/dhruvasagar/vim-table-mode
" <leader>tm enables table mode
Plug 'dhruvasagar/vim-table-mode'

" Make vim more Puppet friendly!
" https://github.com/rodjek/vim-puppet
Plug 'rodjek/vim-puppet'

" A Vim wrapper for running tests on different granularities.
" https://github.com/janko-m/vim-test
Plug 'janko-m/vim-test'

" Bbye allows you to do delete buffers (close files) without closing your windows or messing up your layout.
Plug 'moll/vim-bbye'

" Plugins to load on lance-2022 MacOS laptop
let s:hname = system("hostname -s")
if s:hname == "lance-2025\n"
  " Suggestion and Tab completion
  " Requires a locally-compiled library; see docs. Note this will work
  " fine on Linux, but disabling there since we mostly code on OS X and it
  " can be a hassle to compile the dependent libraries.
  " https://github.com/Valloric/YouCompleteMe
  "Plug 'Valloric/YouCompleteMe', { 'do': './install.py' }
  Plug 'ternjs/tern_for_vim', { 'do': 'npm install' }
  "Plug 'Valloric/YouCompleteMe', { 'do': './install.py --tern-completer' }
  " Newer Homebrew LLVM (v16+) moved libc++ to lib/c++; use a funcref so multi-word
  " LDFLAGS don't require any Vimscript string escaping.
  function! YcmInstallWithLLVM(info)
    let l:flags  = '-L/opt/homebrew/opt/llvm/lib'
    let l:flags .= ' -L/opt/homebrew/opt/llvm/lib/c++'
    let l:flags .= ' -Wl,-rpath,/opt/homebrew/opt/llvm/lib/c++'
    let l:cmd  = 'env CC=/opt/homebrew/opt/llvm/bin/clang'
    let l:cmd .= ' CXX=/opt/homebrew/opt/llvm/bin/clang++'
    let l:cmd .= ' LDFLAGS=' . shellescape(l:flags)
    let l:cmd .= ' CPPFLAGS=-I/opt/homebrew/opt/llvm/include'
    let l:cmd .= ' MACOSX_DEPLOYMENT_TARGET=13.0'
    let l:cmd .= ' ./install.py --tern-completer'
    call system(l:cmd)
  endfunction
  Plug 'Valloric/YouCompleteMe', { 'do': function('YcmInstallWithLLVM') }

  " This plugin adds Copilot-like code completion support to Vim. It uses Ollama
  " as a backend, which can run locally and does not require cloud services,
  " thus preserving your privacy.
  " https://github.com/gergap/vim-ollama
  " Plug 'gergap/vim-ollama'


  " set breakpoints to be able to debug vim plugins
  "Plug 'vim-scripts/genutils'
  "Plug 'albfan/vim-breakpts'
endif

call plug#end()

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" SETTINGS
" tpope/vim-sensible is inlined here & used as a baseline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

set autoindent		" preserve indent level on newlines
set noexpandtab		" use tabs, not spaces
set tabstop=4		" a tab is 4 spaces
set shiftwidth=4	" an autoindent (with <<) is 4 spaces
set softtabstop=4	" tabwidth in insert mode
set smarttab		" use shiftwidth/tabstop based on context

set backspace=indent,eol,start " Allow backspace in insert mode

set lazyredraw      " redraw only when we need to.

" By default, complete is set to: complete=.,w,b,u,t,i
" The 'i' means 'included files' and can result in major slowdowns
set complete-=i

" Don't assume numbers starting with zero are octal
set nrformats-=octal

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
set notimeout
set ttimeout
set ttimeoutlen=10

set incsearch		" incremental searching
set hlsearch		" highlight matches
set ignorecase		" serach are case insensitive...
set smartcase		" ... unless they contain at least one capital letter

set laststatus=2	" always show the status line
set ruler			" show cursor position (overridden by statusline)
set showcmd			" show partial command in bottom-right
set showtabline=1	" Show tabline only when more than one tab exists
set title           " Show the filename in the window titlebar

set wildmenu 		" use tab completion on command line

" let spacebar double as our leader, for great justice
let mapleader = " " " <space>
let maplocalleader = "\\"

" Better tab completion
set wildmode=longest,list

set showmatch		" Show the matching brace

" force error bells off - may not work on normal vim or linux
set vb t_vb=

" Controls the number of lines/chars to keep visible before scrolling
set scrolloff=3
set sidescrolloff=10
set sidescroll=1
set display+=lastline " show the last line that fits in window (vs '@@@@')

" Changes what Vim displays for special chars like trailing space & tabs
set nolist " Don't show invisible characters
" let &listchars = "tab:>-,trail:\u2591,extends:>,precedes:<,nbsp:\u00b7"
let &listchars = "tab:|\ ,trail:\u2591,extends:>,precedes:<,nbsp:\u00b7"

" The semicolon will cause Vim to search back (up) in the directory tree
if has('path_extra')
  setglobal tags-=./tags tags^=./tags;
endif

set autoread 			" reload unchanged buffers when file changed outside vim

" remember more than 1000 previous search/commands
if &history < 1000
  set history=1000
endif

" max number of tab page that can be opened
if &tabpagemax < 50
  set tabpagemax=50
endif

" Control what is preserved in the viminfo file
"   ! save and restore all-caps-named GLOBAL variables
"   ' number of files for which we should remember marks
"   < maximum line count of a register that is saved
"   s maximum byte count of a register that is saved
"   h disable the hlsearch when loading viminfo
"   no '/' specified means use value of 'history' for saving searches
"   no ':' specified means use value of 'history' for command line history
"   no '%' specified means don't save/reload the buffer list
"   no 'n<file>' specified means use default location for .viminfo
set viminfo=!,'100,<1000,s100,h

set sessionoptions-=options " exclude options from the :mksession command

" Load matchit.vim for extended % matching (HTML tags, if/else/endif, etc.)
if !exists('g:loaded_matchit')
  if has('packages')
    silent! packadd matchit
  else
    runtime! macros/matchit.vim
  endif
endif

" Set colorscheme
" Allow color schemes to do bright colors without forcing bold.
if &t_Co == 8 && $TERM !~# '^linux'
  set t_Co=16
endif
if $TERM =~ "-256color"
  set t_Co=256
endif
set background=dark
silent! colorscheme gruvbox
let g:airline_theme='gruvbox'
" silent! colorscheme solarized
" let g:airline_theme='solarized'
" silent! colorscheme monokai
" let g:airline_theme='molokai'
" silent! colorscheme OceanicNext
" let g:airline_theme='oceanicnext'
" silent! colorscheme badwolf
" let g:airline_theme='badwolf'
" silent! colorscheme wombat
" let g:airline_theme='wombat'

" Allow gx to open urls in the browser
if has('mac')
  let g:netrw_browsex_viewer = 'open'
else
  let g:netrw_browsex_viewer = 'xdg-open'
endif

" Centralize backups, swapfiles and undo history
set swapfile
set directory=~/.vim/swaps//
set backup
set backupdir=~/.vim/backups//
if has('persistent_undo')
  if exists("&undodir")
    set undofile
    set undodir=~/.vim/undo//
    set undoreload=10000
  endif
endif
set undolevels=10000

" Resize splits when the window is resized
au VimResized * :wincmd =

" Use relative line numbers
if exists("&relativenumber")
  set relativenumber
  autocmd BufReadPost * set relativenumber
endif

" Line numbers
set number

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
"set t_ti= t_te=

set nowrap        " don't wrap lines (we map leader-W to toggle)
set linebreak     " when wrapping, wrap at word boundaries (vs last char)
if exists('+breakindent')
	set breakindent " preserves the indent level of wrapped lines
	set showbreak=â†ª " illustrate wrapped lines
	set wrap        " wrapping with breakindent is tolerable
endif
" When on first/last char in a line, allow left/right to navigate
" through to the prev/next line.
set whichwrap+=<,>,h,l

set foldenable          " enable folding
set foldlevelstart=10   " open most folds by default
set foldnestmax=10      " 10 nested fold max
set foldmethod=indent   " fold based on indent level

" Create new splits to the right and below
set splitright
set splitbelow

" allow modified buffers to be hidden
set hidden

" exclusions from the autocomplete menu
set wildignore+=*/tmp/*,*/node_modules/*

" mouse works in most terminal software we use...
set mouse=a

" change the cursor shape depending on mode
" Uses standard DECSCUSR escape sequences (works across modern terminals)
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"

" highlight current line
"set cursorline

" Set up vertical ruler at 80 characters in
" if exists('+colorcolumn')
"   set colorcolumn=100
" endif

" Don't try to highlight lines longer than 800 characters.
set synmaxcol=800

" Vim-session Config
let g:session_autosave = 'no'

" vim-json config
let g:vim_json_syntax_conceal = 0

" YouCompleteMe Config
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
" Remove <TAB> because it conflicts with Snipmate
" Note that it's easier to navigate the suggestions with C-n/C-p anyway
let g:ycm_key_list_select_completion   = ['<C-j>', '<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-k>', '<C-p>', '<Up>']

" UltiSnips config
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" SnipMate config
let g:snipMate = { 'snippet_version': 0 }

" easier emojis!
set completefunc=emoji#complete
vnoremap <c-e> :s/:\([^:]\+\):/\=emoji#for(submatch(1), submatch(0))/<CR>:nohlsearch<CR>:redraw!<CR>

" Argwrap config
nnoremap <silent> <leader>A :ArgWrap<CR>
let g:argwrap_tail_comma = 1

" Gitgutter config
if exists('&signcolumn')
  set signcolumn=yes
else
  let g:gitgutter_sign_column_always = 1
endif

if version >= 800
  " ALE linter config
  " let g:ale_sign_column_always = 1
  let g:ale_sign_error = 'âœ—'
  let g:ale_sign_warning = 'âš '
  " let g:ale_php_phpcs_standard = 'PSR2'
  let g:ale_php_phpcs_standard = 'phpcs.xml'
  " let g:ale_php_phpcs_standard = '/web/lbriedendev.com/git/ets/www/phpcs.xml'
  " let g:ale_php_phpcs_use_global = 1
  " let g:ale_php_phpcs_executable = 'phpcs -a --standard=phpcs.xml'
  " let g:ale_fixers = []
  " let g:ale_fixers.javascript = ['eslint']
  " Turn on all php linters except phpcs and phpmd
  let g:ale_linters = {
  \   'php': ['hack', 'langserver', 'php', 'phpstan'], 'perl': ['syntax-check','perlcritic'],
  \}
  " Unless we are in api or phpunit directories, then turn on ones we actually use
  let g:ale_pattern_options = {
  \   'www/.\+/\(api\|phpunit\|codeception-new\)/.\+\.phph\?$': {
  \       'ale_linters': {'php': ['php', 'phpcs', 'phpmd']},
  \   },
  \}
else
  " Syntastic config
  let g:syntastic_enable_signs = 1 " check if this slows things down
  let g:syntastic_check_on_open = 1
  let g:syntastic_error_symbol = 'âœ—'
  let g:syntastic_warning_symbol = 'âš '
  let g:syntastic_auto_jump = 0
  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_javascript_checkers = ['eslint']
  "let g:syntastic_php_phpcs_args="--standard=PSR2"
  let g:puppet_module_detect=1
  let g:syntastic_puppet_puppetlint_args = "--no-80-chars-check --no-class_inherits_from_params_class-check"
  let g:syntastic_mode_map = { 'mode': 'active',
    \ 'active_filetypes': ['javascript', 'python', 'perl', 'sh', 'puppet'],
    \ 'passive_filetypes': ['html','php'] }
endif

" editorconfig config
let g:EditorConfig_exclude_patterns = ['fugitive://.*']

" JSDoc config
let g:jsdoc_enable_es6 = 1

" ============================================================================
" FZF {{{
" ============================================================================
" (replaces Ctrl-P, FuzzyFinder and Command-T)

" Hide statusline of terminal buffer
autocmd! FileType fzf
autocmd  FileType fzf set laststatus=0 noshowmode noruler
  \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

nnoremap <silent> <Leader>o :Files<CR>
nnoremap <silent> <Leader>;  :Buffers<CR>
nmap <Leader>r :Tags<CR>
" search word under cursor
" nmap <Leader>a :Ag<CR>
nnoremap <silent> <Leader>ag :Ag <C-R><C-W><CR>

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }
" }}}

" Augmenting Ag command using fzf#vim#with_preview function
"   * fzf#vim#with_preview([[options], [preview window], [toggle keys...]])
"     * For syntax-highlighting, Ruby and any of the following tools are required:
"       - Bat: https://github.com/sharkdp/bat
"       - Highlight: http://www.andre-simon.de/doku/highlight/en/highlight.php
"       - CodeRay: http://coderay.rubychan.de/
"       - Rouge: https://github.com/jneen/rouge
"
"   :Ag  - Start fzf with hidden preview window that can be enabled with "?" key
"   :Ag! - Start fzf in fullscreen and display the preview window above
command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>,
  \     <bang>0 ? fzf#vim#with_preview('up:60%')
  \     : fzf#vim#with_preview('right:50%:hidden', '?'),
  \     <bang>0)

" highlight trailing whitespace
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" STATUS LINE (won't see much unless we disable Airline)
" see: :help 'statusline
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" status bar
"set statusline=%F%m%r%h%w\  "fullpath and status modified sign
set statusline=%f%m%r%h%w\  "path and status modified sign
set statusline+=\ %y "filetype
set statusline+=%=
set statusline+=\ [%l\/%L:\%v] "line number and column number

" Airline.vim customizations
" Use the poweline fonts to make airline pretty
let g:airline_powerline_fonts = 1
if version >= 703
  let g:airline#extensions#tabline#enabled = 1
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MAPPINGS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" :map       Normal, Visual and Operator-pending
" :vmap      Visual
" :nmap      Normal
" :omap      Operator-pending (Eg: dw where d is operator character and w is motion character)
" :map!      Insert and Command-line
" :imap      Insert
" :cmap      Command-line
"
" Quick ESC
" Some people map jk for this, but it makes Dijkstra sad.
" imap kj <ESC>
inoremap jj <ESC>

" Insert the hashrocket with CTRL+l
inoremap <c-l> <space>=><space>
" inoremap <c-l> ()<space>=><space>{<return><return>}

" map j to gj and k to gk, so line navigation ignores line wrap
" ...but only if the count is undefined (otherwise, things like 4j
" break if wrapped LINES are present)
nmap <expr> j (v:count == 0 ? 'gj' : 'j')
nmap <expr> k (v:count == 0 ? 'gk' : 'k')

" Navigate splits more easily
nmap <C-h> <C-w>h
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-l> <C-w>l

noremap <leader>v <C-w>v

" List navigation
nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>    :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz

" Key repeat hack for resizing splits, i.e., <C-w>+++- vs <C-w>+<C-w>+<C-w>-
" see: http://www.vim.org/scripts/script.php?script_id=2223
nmap <C-w>+ <C-w>+<SID>ws
nmap <C-w>- <C-w>-<SID>ws
nmap <C-w>> <C-w>><SID>ws
nmap <C-w>< <C-w><<SID>ws
nnoremap <script> <SID>ws+ <C-w>+<SID>ws
nnoremap <script> <SID>ws- <C-w>-<SID>ws
nnoremap <script> <SID>ws> <C-w>><SID>ws
nnoremap <script> <SID>ws< <C-w><<SID>ws
nmap <SID>ws <Nop>

" Tab handling
nnoremap <leader>( :tabprev<cr>
nnoremap <leader>) :tabnext<cr>
nnoremap <C-t> :tabnew<CR>
"nnoremap <C-j> :tabprevious<CR>
"nnoremap <C-k> :tabnext<CR>
inoremap <C-t> <Esc>:tabnew<CR>
"inoremap <C-j> <Esc>:tabprevious<CR>i
"inoremap <C-k> <Esc>:tabnext<CR>i

" Allow for some common quit/write cmd typos
command! Q q " Bind :Q to :q
command! W w " Bind :W to :w
command! Qall qall

" gv reselects the last visual selection, however doesn't work correctly after
" cut/paste, so next command
" Visually select the text that was last edited/pasted
nmap gV `[v`]

" reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv

" allow the . to execute once for each line of a visual selection
vnoremap . :normal .<CR>

" move selected lines up or down
" vnoremap <C-j> :m '>+1<CR>gv=gv
" vnoremap <C-k> :m '<-2<CR>gv=gv
" more advanced way of moving lines/selections up or down - accepts number of
" times to execute command
function! MoveLineUp()
  call MoveLineOrVisualUp(".", "")
endfunction

function! MoveLineDown()
  call MoveLineOrVisualDown(".", "")
endfunction

function! MoveVisualUp()
  call MoveLineOrVisualUp("'<", "'<,'>")
  normal gv
endfunction

function! MoveVisualDown()
  call MoveLineOrVisualDown("'>", "'<,'>")
  normal gv
endfunction

function! MoveLineOrVisualUp(line_getter, range)
  let l_num = line(a:line_getter)
  if l_num - v:count1 - 1 < 0
    let move_arg = "0"
  else
    let move_arg = a:line_getter." -".(v:count1 + 1)
  endif
  call MoveLineOrVisualUpOrDown(a:range."move ".move_arg)
endfunction

function! MoveLineOrVisualDown(line_getter, range)
  let l_num = line(a:line_getter)
  if l_num + v:count1 > line("$")
    let move_arg = "$"
  else
    let move_arg = a:line_getter." +".v:count1
  endif
  call MoveLineOrVisualUpOrDown(a:range."move ".move_arg)
endfunction

function! MoveLineOrVisualUpOrDown(move_arg)
  let col_num = virtcol(".")
  execute "silent! ".a:move_arg
  execute "normal! ".col_num."|"
endfunction

vnoremap <silent> <C-k> :<C-u>call MoveVisualUp()<CR>
vnoremap <silent> <C-j> :<C-u>call MoveVisualDown()<CR>

" Back to the buffer we came from
nmap <C-e> :e#<CR>

" Easy bouncing buffers
nmap <C-n> :bnext<CR>
nmap <C-p> :bprev<CR>

" Open tag in vertical split
nmap <C-\> :vs <CR>:exec("tag ".expand("<cword>"))<CR>

" Clear search string to remove highlighting
nnoremap <silent> \\ :nohlsearch<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" LEADER MAPPINGS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Reload our .vimrc
nmap <leader>~ :source ~/.vimrc<CR>:redraw!<CR>:AirlineRefresh<CR>:echo "~/.vimrc reloaded!"<CR>

" Write file
nmap <leader>w :w<CR>

" Delete buffer (using vim-bbye)
" nmap <leader>q :bd<CR>
nmap <leader>q :Bdelete<CR>

" Hide buffer
nmap <leader>Q :hide<CR>

" Toggle spelling
nmap <leader>s :set invspell<CR>:set spell?<CR>

" Fix Spelling
nnoremap <Leader>fs 1z=

" Toggle wrap
nmap <leader>W :set invwrap<CR>:set wrap?<CR>

" Open/closes folds
nnoremap <leader>z za

" Toggle background dark/light with <leader>B
function! RD_ToggleBackground()
  if &background == "dark"
    let &background = "light"
    let _snark = "Hey, wake up!!"
  else
    let &background = "dark"
    let _snark = "Who turned out the lights???"
  endif

  if exists(':Airline')
    AirlineRefresh
  endif
  redraw
  echo _snark
endfunction
nmap <silent> <leader>B :call RD_ToggleBackground()<CR>

" Toggle paste mode
set pastetoggle=<F2>

" upper/lower word
" (set a mark, visually select inner word, u/U, return to mark)
nmap <leader>U m`gUiw``
nmap <leader>L m`guiw``

" Reindent the entire file
nmap <leader>= gg=G``:echo "reindent global"<CR>

" Toggle match highlight
nmap <leader>l :set invhlsearch<CR>

" Highlight the current search match when jumping to next
if has('patch-8.1.547')
  " Vim 8.1.547+ has CurSearch highlight group for the active match
  highlight CurSearch ctermfg=white ctermbg=red guifg=white guibg=red
  nnoremap <silent> n nzz
  nnoremap <silent> N Nzz
else
  " Legacy blink workaround: temporarily add a match highlight on the current hit
  function! HLNext (blinktime)
    highlight WhiteOnRed ctermfg=white ctermbg=red
    let [bufnum, lnum, col, off] = getpos('.')
    let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
    let target_pat = '\c\%#'.@/
    let ring = matchadd('WhiteOnRed', target_pat, 101)
    redraw
    exec 'sleep ' . a:blinktime . 'm'
    call matchdelete(ring)
    redraw
  endfunction
  nnoremap <silent> n nzz:call HLNext(300)<cr>
  nnoremap <silent> N Nzz:call HLNext(300)<cr>
endif

" Tabular.vim
nnoremap <Leader>t= :Tabularize assignment<CR>
vnoremap <Leader>t= :Tabularize assignment<CR>
nnoremap <Leader>t: :Tabularize symbol<CR>
vnoremap <Leader>t: :Tabularize symbol<CR>
nnoremap <Leader>t, :Tabularize comma<CR>
vnoremap <Leader>t, :Tabularize comma<CR>
nnoremap <Leader>t/ :Tabularize / \/\/<CR>
vnoremap <Leader>t/ :Tabularize / \/\/<CR>
nnoremap <Leader>t> :Tabularize /=>/<CR>
vnoremap <Leader>t> :Tabularize /=>/<CR>
nnoremap <Leader>t# :Tabularize /#/<CR>
vnoremap <Leader>t# :Tabularize /#/<CR>

" vim-test
nnoremap <leader>tn :TestNearest<CR>
nnoremap <leader>tf :TestFile<CR>
nnoremap <leader>ts :TestSuite<CR>
nnoremap <leader>tl :TestLast<CR>
nnoremap <leader>tv :TestVisit<CR>

" Toggle numbers
nmap <leader>n :setlocal number!<CR><bar>:setlocal relativenumber!<CR>

" unmap F1 - stupid help key
inoremap <F1> <ESC>
nnoremap <F1> <ESC>
vnoremap <F1> <ESC>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" FILE TYPES
"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Some file types should wrap their text
function! RD_SetupWrapping()
  setlocal wrap
  setlocal linebreak
  setlocal textwidth=100
  setlocal nolist
endfunction

" Make sure all markdown files have the correct filetype set and setup wrapping
" augroup markdown
"   autocmd!
"   autocmd BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn,txt} setf markdown
"   autocmd FileType markdown call RD_SetupWrapping()
"   autocmd FileType markdown setlocal ts=4 sts=4 sw=4
" augroup END

" enable spell checking on certain files
augroup Spelling
  autocmd!
  autocmd BufNewFile,BufRead COMMIT_EDITMSG set spell
augroup END

" Javascript
augroup ft_javascript
    au!
    " Prettify a hunk of JSON with <localleader>p
    au FileType javascript nnoremap <buffer> <localleader>p ^vg_:!python -m json.tool<cr>
    au FileType javascript vnoremap <buffer> <localleader>p :!python -m json.tool<cr>
augroup END

" }}}

" Vim
augroup ft_vim
    au!

    au FileType vim setlocal foldmethod=marker keywordprg=:help
    au FileType help setlocal textwidth=100
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

au FileType php,javascript,sql,perl,rgt,c,smarty,python,ruby setlocal list
au FileType javascript,javascript.jsx,json,css,html,yaml,puppet,sh,ruby,eruby,tsx,typescript,typescriptreact,perl setlocal tabstop=2 expandtab shiftwidth=2 softtabstop=2
au FileType python,ruby setlocal textwidth=100

" vim-fugitive bindings
" Each time you open a git object using fugitive it creates a new buffer. This
" means that your buffer listing can quickly become swamped with fugitive
" buffers.Hereâ€™s an autocommand that prevents this from becomming an issue:
autocmd BufReadPost fugitive://* set bufhidden=delete
" The tree buffer makes it easy to drill down through the directories of your
" git repository, but itâ€™s not obvious how you could go up a level to the
" parent directory. Running the following command will open the parent tree:
" :edit %:h
autocmd User fugitive
  \ if get(b:, 'fugitivie_type', '') =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif

" Generate a random password
command! -nargs=1 GeneratePassword execute ":r !openssl rand -base64 48 | tr -d '*/\\\\_-' | cut -c1-<args>"

" Display timestamp under cursor as date
if has('linux')
	nnoremap <leader>ts :echo system('date -d @' . expand('<cword>') . ' "+%Y-%m-%d %H:%M:%S"')<CR>
elseif has('mac') || system('uname') =~? 'freebsd'
	nnoremap <leader>ts :echo system('date -j -f "%s" ' . expand('<cword>') . ' "+%Y-%m-%d %H:%M:%S"')<CR>
endif

" vim:set ft=vim et sw=2:
